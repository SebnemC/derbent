package tech.derbent.abstracts.annotations;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.Arrays;
import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.data.binder.BeanValidationBinder;

import tech.derbent.abstracts.domains.CEntityDB;

/**
 * Integration test demonstrating the new annotation-based ComboBox data provider
 * approach. This test shows how the enhanced CEntityFormBuilder can automatically resolve
 * data providers for ComboBox fields using MetaData annotations, making form creation
 * much simpler and more maintainable.
 * <p>
 * <strong>Key Features Demonstrated:</strong>
 * </p>
 * <ul>
 * <li>Annotation-based data provider configuration</li>
 * <li>Automatic service resolution by naming convention</li>
 * <li>Multiple ComboBox fields with different data sources</li>
 * <li>Backward compatibility with legacy ComboBoxDataProvider</li>
 * <li>Comprehensive error handling and logging</li>
 * </ul>
 */
class CEntityFormBuilderIntegrationTest {

	/**
	 * Example entity demonstrating the new annotation-based approach for multiple
	 * ComboBox fields. This shows how different ComboBox fields can specify their own
	 * data providers without requiring complex logic in the view layer.
	 */
	public static class ExampleEntity extends CEntityDB {

		@MetaData(displayName = "Primary Type", description = "The primary type category",
			order = 1, required = true, dataProviderBean = "primaryTypeService")
		private PrimaryType primaryType;
		@MetaData(displayName = "Secondary Type",
			description = "The secondary type category", order = 2, required = false,
			dataProviderClass = SecondaryTypeService.class,
			dataProviderMethod = "findAllActive")
		private SecondaryType secondaryType;
		@MetaData(displayName = "Related Item",
			description = "Related item using automatic resolution", order = 3,
			required = false
		// No explicit data provider - will use automatic resolution
		)
		private RelatedItem relatedItem;
		@MetaData(displayName = "Entity Name", description = "The name of this entity",
			order = 0, required = true, maxLength = 100)
		private String name;

		// Constructors
		public ExampleEntity() {
			super();
		}

		public ExampleEntity(final String name) {
			super();
			this.name = name;
		}

		public String getName() { return name; }

		// Getters and setters required for Vaadin binding
		public PrimaryType getPrimaryType() { return primaryType; }

		public RelatedItem getRelatedItem() { return relatedItem; }

		public SecondaryType getSecondaryType() { return secondaryType; }

		public void setName(final String name) { this.name = name; }

		public void setPrimaryType(final PrimaryType primaryType) {
			this.primaryType = primaryType;
		}

		public void setRelatedItem(final RelatedItem relatedItem) {
			this.relatedItem = relatedItem;
		}

		public void setSecondaryType(final SecondaryType secondaryType) {
			this.secondaryType = secondaryType;
		}

		@Override
		public String toString() {
			return name != null ? name : "ExampleEntity[" + getId() + "]";
		}
	}

	/**
	 * Example entity type for ComboBox testing
	 */
	public static class PrimaryType extends CEntityDB {

		private String typeName;

		public PrimaryType() {
			super();
		}

		public PrimaryType(final String typeName) {
			super();
			this.typeName = typeName;
		}

		public String getTypeName() { return typeName; }

		public void setTypeName(final String typeName) { this.typeName = typeName; }

		@Override
		public String toString() {
			return typeName != null ? typeName : "PrimaryType[" + getId() + "]";
		}
	}

	/**
	 * Third example entity type for automatic resolution testing
	 */
	public static class RelatedItem extends CEntityDB {

		private String itemName;

		public RelatedItem() {
			super();
		}

		public RelatedItem(final String itemName) {
			super();
			this.itemName = itemName;
		}

		public String getItemName() { return itemName; }

		public void setItemName(final String itemName) { this.itemName = itemName; }

		@Override
		public String toString() {
			return itemName != null ? itemName : "RelatedItem[" + getId() + "]";
		}
	}

	/**
	 * Another example entity type for ComboBox testing
	 */
	public static class SecondaryType extends CEntityDB {

		private String category;

		public SecondaryType() {
			super();
		}

		public SecondaryType(final String category) {
			super();
			this.category = category;
		}

		public String getCategory() { return category; }

		public void setCategory(final String category) { this.category = category; }

		@Override
		public String toString() {
			return category != null ? category : "SecondaryType[" + getId() + "]";
		}
	}

	/**
	 * Mock service for SecondaryType that would be resolved by class
	 */
	public static class SecondaryTypeService {

		public List<SecondaryType> findAllActive() {
			return Arrays.asList(new SecondaryType("Active Category 1"),
				new SecondaryType("Active Category 2"));
		}

		public List<SecondaryType> list() {
			return Arrays.asList(new SecondaryType("All Category 1"),
				new SecondaryType("All Category 2"));
		}
	}

	private BeanValidationBinder<ExampleEntity> binder;

	@BeforeEach
	void setUp() {
		binder = new BeanValidationBinder<>(ExampleEntity.class);
	}

	@Test
	@DisplayName("should maintain backward compatibility with legacy ComboBoxDataProvider")
	void testBackwardCompatibilityWithLegacyProvider() {
		// Given - Create legacy data provider
		final CEntityFormBuilder.ComboBoxDataProvider legacyProvider =
			new CEntityFormBuilder.ComboBoxDataProvider() {

				@Override
				@SuppressWarnings("unchecked")
				public <T extends CEntityDB> List<T> getItems(final Class<T> entityType) {
					if (entityType == PrimaryType.class) {
						return (List<T>) Arrays.asList(new PrimaryType("Legacy Type 1"),
							new PrimaryType("Legacy Type 2"));
					}
					else if (entityType == SecondaryType.class) {
						return (List<T>) Arrays.asList(
							new SecondaryType("Legacy Secondary 1"),
							new SecondaryType("Legacy Secondary 2"));
					}
					return List.of();
				}
			};
		// When - Create form using legacy approach (should still work)
		final Div form =
			CEntityFormBuilder.buildForm(ExampleEntity.class, binder, legacyProvider);
		// Then
		assertNotNull(form, "Form should be created successfully with legacy provider");
		assertEquals("editor-layout", form.getClassName(),
			"Form should have correct CSS class");
		assertTrue(form.getChildren().count() > 0, "Form should contain components");
	}

	@Test
	@DisplayName("should handle entity without ComboBox fields gracefully")
	void testEntityWithoutComboBoxFields() {
		// Given - Simple entity without ComboBox fields
		class SimpleEntity {

			@MetaData(displayName = "Simple Name", required = true, order = 1)
			private String name;
			@MetaData(displayName = "Simple Number", required = false, order = 2)
			private Integer number;

			@SuppressWarnings("unused")
			public String getName() { return name; }

			@SuppressWarnings("unused")
			public Integer getNumber() { return number; }

			@SuppressWarnings("unused")
			public void setName(final String name) { this.name = name; }

			@SuppressWarnings("unused")
			public void setNumber(final Integer number) { this.number = number; }
		}
		final BeanValidationBinder<SimpleEntity> simpleBinder =
			new BeanValidationBinder<>(SimpleEntity.class);
		// When
		final Div form = CEntityFormBuilder.buildForm(SimpleEntity.class, simpleBinder);
		// Then
		assertNotNull(form, "Form should be created successfully");
		assertEquals("editor-layout", form.getClassName(),
			"Form should have correct CSS class");
		// Form should contain the text field and number field components
	}

	@Test
	@DisplayName("should create form with annotation-based ComboBox providers")
	void testFormWithAnnotationBasedProviders() {
		// When - Create form using the new annotation-based approach Note: No explicit
		// ComboBoxDataProvider needed!
		final Div form = CEntityFormBuilder.buildForm(ExampleEntity.class, binder);
		// Then
		assertNotNull(form, "Form should be created successfully");
		assertEquals("editor-layout", form.getClassName(),
			"Form should have correct CSS class");
		assertTrue(form.getChildren().count() > 0, "Form should contain components");
		// The form should be created even though the actual Spring services are not
		// available in this test environment - the form builder handles missing services
		// gracefully
	}

	@Test
	@DisplayName("should demonstrate the improved developer experience")
	void testImprovedDeveloperExperience() {
		/*
		 * This test demonstrates how the new annotation-based approach dramatically
		 * simplifies form creation for developers: OLD APPROACH (complex, error-prone):
		 * =================================== ComboBoxDataProvider provider = new
		 * ComboBoxDataProvider() {
		 * @Override public <T extends CEntityDB> List<T> getItems(Class<T> entityType) {
		 * if (entityType == PrimaryType.class) { return (List<T>)
		 * primaryTypeService.list(Pageable.unpaged()); } else if (entityType ==
		 * SecondaryType.class) { return (List<T>) secondaryTypeService.findAllActive(); }
		 * else if (entityType == RelatedItem.class) { return (List<T>)
		 * relatedItemService.list(); } // What if we add more ComboBox fields? More
		 * if-else blocks! // What if we forget to handle a type? Silent bugs! return
		 * Collections.emptyList(); } }; Div form =
		 * CEntityFormBuilder.buildForm(ExampleEntity.class, binder, provider); NEW
		 * APPROACH (simple, maintainable): ==================================== // Just
		 * annotations in the entity - no complex provider logic needed!
		 * @MetaData(dataProviderBean = "primaryTypeService") private PrimaryType
		 * primaryType;
		 * @MetaData(dataProviderClass = SecondaryTypeService.class, dataProviderMethod =
		 * "findAllActive") private SecondaryType secondaryType; // Automatic resolution -
		 * no annotation needed if following naming convention! private RelatedItem
		 * relatedItem; // In the view - super simple! Div form =
		 * CEntityFormBuilder.buildForm(ExampleEntity.class, binder);
		 */
		// When - Using the new simplified approach
		final Div form = CEntityFormBuilder.buildForm(ExampleEntity.class, binder);
		// Then - Form creation is much simpler and less error-prone
		assertNotNull(form, "Form should be created with minimal code");
		// The annotation-based approach provides: 1. Better separation of concerns (data
		// provider config is with the field definition) 2. Automatic resolution reduces
		// boilerplate code 3. Type safety at annotation level 4. Easier maintenance when
		// adding new ComboBox fields 5. Self-documenting code (you can see the data
		// source right at the field)
		assertTrue(true,
			"New approach successfully demonstrates improved developer experience");
	}
}